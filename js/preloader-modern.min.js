/**
 * Modern Preloader System with Service Worker Integration
 * Follows modern loading patterns and best practices
 */

// IMMEDIATE TEST - This should show in console if file loads
console.log('ðŸ”¥ [IMMEDIATE TEST] preloader-modern.js file loaded successfully!');
console.log('ðŸ”¥ [IMMEDIATE TEST] Timestamp:', new Date().toISOString());
console.log('ðŸ”¥ [IMMEDIATE TEST] Document readyState:', document.readyState);
console.log('ðŸ”¥ [IMMEDIATE TEST] Anime.js available:', typeof anime !== 'undefined');

class ModernPreloader {
  constructor(options = {}) {
    this.config = {
      maxDuration: 3000, // Increased to make animations more visible
      minDuration: 2000,  // Increased minimum duration
      reducedMotion: window.matchMedia('(prefers-reduced-motion: reduce)').matches,
      debug: false,
      ...options
    };

    this.state = {
      isActive: false,
      isCompleted: false,
      isSkipped: false,
      startTime: null,
      progress: 0,
      resourcesLoaded: 0,
      totalResources: 0,
      intervals: new Set(),
      timeouts: new Set(),
      animations: new Set()
    };

    this.elements = {};
    this.loadingStages = [
      { name: 'Initializing', status: 'Loading core components' },
      { name: 'Loading Resources', status: 'Fetching assets & data' },
      { name: 'Ready to Launch', status: 'Almost there...' }
    ];

    this.init();
  }

  async init() {
    try {
      this.cacheElements();
      this.setupEventListeners();
      await this.start();
    } catch (error) {
      this.handleError('Initialization failed', error);
    }
  }

  cacheElements() {
    const elementIds = [
      'preloader', 'logoContainer', 'logoA', 'logoC', 'rotatingRing',
      'particleOrbit', 'progressFill', 'loadingText', 'loadingStatus',
      'loadingPercentage', 'skipPreloader'
    ];

    elementIds.forEach(id => {
      this.elements[id] = document.getElementById(id);
    });

    // Cache orbit particles
    this.elements.orbitParticles = document.querySelectorAll('.orbit-particle');
    this.elements.ringSegments = document.querySelectorAll('.ring-segment');
    this.elements.bgParticles = document.querySelectorAll('.bg-particle');

    // Validate critical elements
    if (!this.elements.preloader) {
      throw new Error('Preloader element not found');
    }
  }

  setupEventListeners() {
    // Skip button
    if (this.elements.skipPreloader) {
      this.elements.skipPreloader.addEventListener('click', () => this.skip());
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && this.state.isActive) {
        this.skip();
      }
    });

    // Page visibility
    document.addEventListener('visibilitychange', () => {
      if (document.hidden && this.state.isActive) {
        this.skip();
      }
    });

    // Window beforeunload
    window.addEventListener('beforeunload', () => this.cleanup());
  }

  // Service Worker functionality removed - not needed for simple portfolio

  async start() {
    if (this.state.isActive) return;

    this.state.isActive = true;
    this.state.startTime = performance.now();
    this.log('Preloader started');

    // Show preloader
    if (this.elements.preloader) {
      this.elements.preloader.style.display = 'flex';
      this.elements.preloader.classList.remove('hidden');
    }

    // Start loading sequence
    await Promise.all([
      this.startResourceMonitoring(),
      this.startAnimationSequence(),
      this.startProgressTracking()
    ]);
  }

  async startResourceMonitoring() {
    // Simplified resource monitoring without service worker complexity
    this.log('Starting simplified resource monitoring');

    // Quick resource simulation for smooth progress animation (faster timing)
    setTimeout(() => {
      this.state.resourcesLoaded = 0.3;
      this.log('Resource loading: 30%');
    }, 50);

    setTimeout(() => {
      this.state.resourcesLoaded = 0.7;
      this.log('Resource loading: 70%');
    }, 150);

    setTimeout(() => {
      this.state.resourcesLoaded = 1;
      this.log('Resource loading complete');
    }, 250);
  }

  async startAnimationSequence() {
    if (this.config.reducedMotion) {
      return this.startReducedMotionSequence();
    }

    // Start logo animation
    this.animateLogoEntrance();
    
    // Start rotating ring
    this.animateRotatingRing();
    
    // Start orbiting particles
    this.animateOrbitingParticles();
    
    // Start background particles
    this.animateBackgroundParticles();
  }

  startReducedMotionSequence() {
    // Show elements immediately without complex animations
    anime.set(this.elements.logoA, { opacity: 1, translateY: 0 });
    anime.set(this.elements.logoC, { opacity: 1, translateY: 0 });
    anime.set(this.elements.ringSegments, { opacity: 0.8 });
    anime.set(this.elements.orbitParticles, { opacity: 0.8 });
    anime.set(this.elements.bgParticles, { opacity: 0.6 });
  }

  animateLogoEntrance() {
    // Enhanced cyberpunk logo entrance with glow effects
    anime.timeline({
      easing: 'easeOutCubic',
      duration: 1500
    })
    .add({
      targets: this.elements.logoA,
      opacity: [0, 1],
      translateY: [-30, 0],
      scale: [0.8, 1],
      rotate: [-5, 0],
      duration: 800,
      complete: () => {
        // Add glow effect after entrance
        anime({
          targets: this.elements.logoA,
          textShadow: [
            '0 0 0px rgba(0, 212, 255, 0)',
            '0 0 20px rgba(0, 212, 255, 0.8)',
            '0 0 10px rgba(0, 212, 255, 0.5)'
          ],
          duration: 600,
          easing: 'easeInOutQuad'
        });
      }
    })
    .add({
      targets: this.elements.logoC,
      opacity: [0, 1],
      translateY: [-30, 0],
      scale: [0.8, 1],
      rotate: [5, 0],
      duration: 800,
      complete: () => {
        // Add glow effect after entrance
        anime({
          targets: this.elements.logoC,
          textShadow: [
            '0 0 0px rgba(0, 212, 255, 0)',
            '0 0 20px rgba(0, 212, 255, 0.8)',
            '0 0 10px rgba(0, 212, 255, 0.5)'
          ],
          duration: 600,
          easing: 'easeInOutQuad'
        });
      }
    }, '-=400')
    .add({
      targets: this.elements.logoA,
      scale: [1, 1.1, 1],
      duration: 600,
      easing: 'easeInOutQuad'
    }, '-=200')
    .add({
      targets: this.elements.logoC,
      scale: [1, 1.1, 1],
      duration: 600,
      easing: 'easeInOutQuad'
    }, '-=400')
    .add({
      targets: [this.elements.logoA, this.elements.logoC],
      color: ['#ffffff', '#00d4ff', '#ffffff'],
      duration: 2000,
      easing: 'easeInOutSine',
      loop: true
    });
  }

  animateRotatingRing() {
    // Set initial state
    anime.set(this.elements.ringSegments, {
      opacity: 0,
      rotate: 0,
      scale: 0.8
    });

    // Animate ring segments with enhanced effects
    anime.timeline({
      easing: 'easeOutCubic'
    })
    .add({
      targets: this.elements.ringSegments,
      opacity: [0, 0.8],
      scale: [0.8, 1],
      duration: 600,
      delay: anime.stagger(150, { from: 'center' }),
      complete: () => {
        // Add pulsing glow effect to ring segments
        anime({
          targets: this.elements.ringSegments,
          opacity: [0.8, 1, 0.8],
          filter: [
            'brightness(1) drop-shadow(0 0 5px rgba(0, 212, 255, 0.5))',
            'brightness(1.2) drop-shadow(0 0 15px rgba(0, 212, 255, 0.8))',
            'brightness(1) drop-shadow(0 0 5px rgba(0, 212, 255, 0.5))'
          ],
          duration: 2000,
          easing: 'easeInOutSine',
          loop: true,
          delay: anime.stagger(200)
        });
      }
    })
    .add({
      targets: this.elements.rotatingRing,
      rotate: '360deg',
      duration: 4000,
      easing: 'linear',
      loop: true
    }, '-=600')
    .add({
      targets: this.elements.rotatingRing,
      scale: [1, 1.05, 1],
      duration: 3000,
      easing: 'easeInOutSine',
      loop: true
    }, '-=4000');
  }

  animateOrbitingParticles() {
    // Set initial state
    anime.set(this.elements.orbitParticles, {
      opacity: 0,
      scale: 0.3
    });

    // Animate particles entrance with smoother, more subtle effects
    anime.timeline({
      easing: 'easeOutCubic'
    })
    .add({
      targets: this.elements.orbitParticles,
      opacity: [0, 0.7],
      scale: [0.3, 0.6],
      duration: 800,
      delay: anime.stagger(100)
    })
    .add({
      targets: '.particle-1',
      translateX: [0, '94px'],
      translateY: [0, 0],
      duration: 3000,
      easing: 'easeInOutQuad',
      direction: 'alternate',
      loop: true
    }, '-=100')
    .add({
      targets: '.particle-2',
      translateX: [0, 0],
      translateY: [0, '94px'],
      duration: 3500,
      easing: 'easeInOutQuad',
      direction: 'alternate',
      loop: true
    }, '-=3000')
    .add({
      targets: '.particle-3',
      translateX: [0, '-94px'],
      translateY: [0, 0],
      duration: 2800,
      easing: 'easeInOutQuad',
      direction: 'alternate',
      loop: true
    }, '-=3500')
    .add({
      targets: '.particle-4',
      translateX: [0, 0],
      translateY: [0, '-94px'],
      duration: 3200,
      easing: 'easeInOutQuad',
      direction: 'alternate',
      loop: true
    }, '-=2800')
    .add({
      targets: '.particle-5',
      translateX: [0, '67px'],
      translateY: [0, '-67px'],
      duration: 2600,
      easing: 'easeInOutQuad',
      direction: 'alternate',
      loop: true
    }, '-=3200')
    .add({
      targets: '.particle-6',
      translateX: [0, '-67px'],
      translateY: [0, '67px'],
      duration: 3400,
      easing: 'easeInOutQuad',
      direction: 'alternate',
      loop: true
    }, '-=2600');
  }

  animateBackgroundParticles() {
    // Animate background particles entrance with enhanced effects
    anime({
      targets: this.elements.bgParticles,
      opacity: [0, 1],
      scale: [0, 1],
      duration: 1000,
      delay: anime.stagger(200),
      easing: 'easeOutQuad',
      complete: () => {
        // Add floating animation to background particles
        anime({
          targets: this.elements.bgParticles,
          translateY: [
            { value: -10, duration: 2000 },
            { value: 10, duration: 2000 }
          ],
          translateX: [
            { value: -5, duration: 1500 },
            { value: 5, duration: 1500 }
          ],
          opacity: [1, 0.6, 1],
          duration: 4000,
          easing: 'easeInOutSine',
          loop: true,
          delay: anime.stagger(300)
        });
        
        // Add subtle pulsing glow to background particles
        anime({
          targets: this.elements.bgParticles,
          filter: [
            'brightness(0.8) drop-shadow(0 0 2px rgba(0, 212, 255, 0.4))',
            'brightness(1.2) drop-shadow(0 0 6px rgba(0, 212, 255, 0.7))',
            'brightness(0.8) drop-shadow(0 0 2px rgba(0, 212, 255, 0.4))'
          ],
          duration: 3000,
          easing: 'easeInOutSine',
          loop: true,
          delay: anime.stagger(400)
        });
      }
    });
  }

  async startProgressTracking() {
    let currentStage = 0;
    let displayProgress = 0;

    const intervalId = setInterval(() => {
      if (this.state.isCompleted || this.state.isSkipped) {
        clearInterval(intervalId);
        return;
      }

      // Simplified progress calculation
      const elapsed = performance.now() - this.state.startTime;
      const timeProgress = Math.min((elapsed / this.config.maxDuration) * 100, 100);
      const resourceProgress = this.state.resourcesLoaded * 100;

      // Combine time and resource progress
      const targetProgress = Math.max(timeProgress, resourceProgress);

      // Balanced progress update
      if (displayProgress < targetProgress) {
        const increment = Math.min(targetProgress - displayProgress, Math.random() * 6 + 3); // Balanced increment
        displayProgress += increment;
      }

      displayProgress = Math.min(displayProgress, 100);
      this.state.progress = displayProgress;

      // Update UI
      this.updateProgressUI(displayProgress);

      // Update stage
      const newStage = Math.floor((displayProgress / 100) * this.loadingStages.length);
      if (newStage > currentStage && newStage < this.loadingStages.length) {
        currentStage = newStage;
        this.updateLoadingStage(currentStage);
      }

      // Check completion
      if (displayProgress >= 100 && this.state.resourcesLoaded >= 0.8) {
        clearInterval(intervalId);
        this.scheduleCompletion();
      }
    }, 50); // Faster update interval (was 100ms)

    this.state.intervals.add(intervalId);
  }

  updateProgressUI(progress) {
    if (this.elements.progressFill) {
      // Use direct style update for smoother progress bar
      this.elements.progressFill.style.width = progress + '%';

      // Optional: Add smooth transition via CSS
      this.elements.progressFill.style.transition = 'width 0.2s ease-out';

      this.log(`Progress updated: ${progress.toFixed(1)}%`);
    }

    if (this.elements.loadingPercentage) {
      this.elements.loadingPercentage.textContent = Math.floor(progress) + '%';
    }
  }

  updateLoadingStage(stageIndex) {
    const stage = this.loadingStages[stageIndex];
    if (!stage) return;

    if (this.elements.loadingText) {
      // Animate text change
      anime({
        targets: this.elements.loadingText,
        opacity: [1, 0],
        translateY: [0, -10],
        duration: 300,
        easing: 'easeOutQuad',
        complete: () => {
          this.elements.loadingText.textContent = stage.name;
          anime({
            targets: this.elements.loadingText,
            opacity: [0, 1],
            translateY: [10, 0],
            duration: 300,
            easing: 'easeOutQuad'
          });
        }
      });
    }

    if (this.elements.loadingStatus) {
      // Animate status change
      anime({
        targets: this.elements.loadingStatus,
        opacity: [1, 0],
        translateY: [0, -10],
        duration: 300,
        easing: 'easeOutQuad',
        complete: () => {
          this.elements.loadingStatus.textContent = stage.status;
          anime({
            targets: this.elements.loadingStatus,
            opacity: [0, 1],
            translateY: [10, 0],
            duration: 300,
            easing: 'easeOutQuad'
          });
        }
      });
    }

    // Initial fade in for loading text elements
    if (stageIndex === 0) {
      anime({
        targets: [this.elements.loadingText, this.elements.loadingStatus],
        opacity: [0, 1],
        translateY: [20, 0],
        duration: 500,
        delay: 800,
        easing: 'easeOutQuad'
      });
    }

    this.log(`Stage ${stageIndex + 1}: ${stage.name}`);
  }

  scheduleCompletion() {
    const elapsed = performance.now() - this.state.startTime;
    const remainingTime = Math.max(this.config.minDuration - elapsed, 0);

    const timeoutId = setTimeout(() => {
      this.complete();
    }, remainingTime);

    this.state.timeouts.add(timeoutId);
  }

  skip() {
    if (this.state.isCompleted || this.state.isSkipped) return;

    this.log('Preloader skipped by user');
    this.state.isSkipped = true;
    this.complete();
  }

  async complete() {
    if (this.state.isCompleted) return;

    this.state.isCompleted = true;
    this.log('Preloader completing...');

    // Cleanup
    this.cleanup();

    // Final animation
    await this.playExitAnimation();

    // Hide preloader
    if (this.elements.preloader) {
      this.elements.preloader.style.display = 'none';
    }

    // Initialize main site
    this.initializeMainSite();

    this.log('Preloader completed');
  }

  async playExitAnimation() {
    if (this.config.reducedMotion) {
      return anime({
        targets: this.elements.preloader,
        opacity: [1, 0],
        duration: 300,
        easing: 'easeOutQuad'
      }).finished;
    }

    // Enhanced cyberpunk exit animation with burst effect
    const timeline = anime.timeline({
      easing: 'easeInOutQuad'
    });

    timeline
      .add({
        targets: '.loading-progress-container',
        opacity: [1, 0],
        translateY: [0, 20],
        duration: 400
      })
      .add({
        targets: [this.elements.loadingText, this.elements.loadingStatus],
        opacity: [1, 0],
        translateY: [0, -10],
        duration: 300,
        delay: anime.stagger(50)
      }, '-=200')
      .add({
        targets: this.elements.orbitParticles,
        scale: [0.6, 0.3],
        opacity: [0.7, 0],
        duration: 400,
        delay: anime.stagger(50),
        easing: 'easeOutQuad'
      }, '-=300')
      .add({
        targets: this.elements.ringSegments,
        rotate: '+=360deg',
        scale: [1, 0],
        opacity: [1, 0],
        filter: [
          'brightness(1) drop-shadow(0 0 5px rgba(0, 212, 255, 0.5))',
          'brightness(2) drop-shadow(0 0 20px rgba(0, 212, 255, 1))',
          'brightness(0) drop-shadow(0 0 0px rgba(0, 212, 255, 0))'
        ],
        duration: 500,
        delay: anime.stagger(50),
        easing: 'easeInQuad'
      }, '-=400')
      .add({
        targets: this.elements.bgParticles,
        scale: [1, 0],
        opacity: [1, 0],
        duration: 400,
        delay: anime.stagger(30),
        easing: 'easeInQuad'
      }, '-=500')
      .add({
        targets: [this.elements.logoA, this.elements.logoC],
        scale: [1, 1.3, 0.5],
        opacity: [1, 1, 0],
        translateY: [0, -20, -40],
        filter: [
          'brightness(1) drop-shadow(0 0 10px rgba(0, 212, 255, 0.5))',
          'brightness(2) drop-shadow(0 0 30px rgba(0, 212, 255, 1))',
          'brightness(3) drop-shadow(0 0 50px rgba(0, 212, 255, 0))'
        ],
        duration: 800,
        delay: anime.stagger(100),
        easing: 'easeInQuad'
      }, '-=500')
      .add({
        targets: this.elements.preloader,
        opacity: [1, 0],
        filter: [
          'brightness(1)',
          'brightness(1.5)',
          'brightness(0)'
        ],
        duration: 600
      }, '-=300');

    return timeline.finished;
  }

  cleanup() {
    // Clear intervals
    this.state.intervals.forEach(id => clearInterval(id));
    this.state.intervals.clear();

    // Clear timeouts
    this.state.timeouts.forEach(id => clearTimeout(id));
    this.state.timeouts.clear();

    // Stop animations
    this.state.animations.forEach(animation => {
      if (animation.pause) animation.pause();
    });
    this.state.animations.clear();
  }

  initializeMainSite() {
    // Dispatch custom event for main site initialization
    document.dispatchEvent(new CustomEvent('preloaderComplete', {
      detail: {
        duration: performance.now() - this.state.startTime,
        resourcesLoaded: this.state.resourcesLoaded,
        wasSkipped: this.state.isSkipped
      }
    }));

    // Initialize main animations if function exists
    if (typeof initMainAnimations === 'function') {
      initMainAnimations();
    }
  }

  handleError(message, error) {
    console.error(`Preloader Error: ${message}`, error);
    
    if (this.elements.preloader) {
      this.elements.preloader.classList.add('error');
    }

    if (this.elements.loadingText) {
      this.elements.loadingText.textContent = 'Error occurred, continuing...';
    }

    // Continue with completion after short delay
    setTimeout(() => this.complete(), 1000);
  }

  delay(ms) {
    return new Promise(resolve => {
      const timeoutId = setTimeout(resolve, ms);
      this.state.timeouts.add(timeoutId);
    });
  }

  log(...args) {
    if (this.config.debug) {
      console.log('[Preloader]', ...args);
    }
  }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  window.preloader = new ModernPreloader({
    debug: false, // Set to false for production
    maxDuration: 2000, // Increased duration to make animations more visible
    minDuration: 1000  // Increased minimum duration
  });
});

// Export for module systems
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ModernPreloader;
}
